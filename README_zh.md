总结了一些python开发/部署/调试/目录结构上一些经验
心血来潮,想写一个关于敏捷开发的python项目模板,让大家快速的开发一个python项目,并且拥有一个比较好,易于扩展的的开发模板.
当然我也看到一些好的关于python的DDD设计项目 例如https://github.com/pgorecki/python-ddd


我的开发原则是 能不引入第三方库就不引入!!!

其中Repository模式则是借鉴了DDD(Domain Driven Design)的设计模型. 存储库通常具有 CRUD 方法，例如 create（）、get（） 或 update（）等方法.
在外部调用时,完全不用关注内部逻辑,并对很多通用逻辑做了最大限度的封装,不需要重复写一些基础的get,gets查询;对于通用的is_deleted这种软删除也做了统一处理,不必过多重复的去写is_deleted=False的where条件

当然这个项目的设计是按照敏捷开发模型实现的,如果是更大型的项目推荐使用DDD的设计模型,只需要按照infra/seedwork的模型复制到各个子app中即可,而seedwork只存放一些globals的模块

DDD的架构设计有几个点我觉得在项目设计上很有用,
1. domain的隔离,是做好业务拆分,为后续扩展做好贮备.
domain A 下面有repo A(管理 数据表table A的CRUD), domain B 下有 repo B(管理 数据表table B的CRUD),如果是在A服务中需要更新TABLE B表,那么应该调用domain B对外暴露的接口,而不是直接调用repo B或者直接操作table B的模型.
2. domain event的设计同样如此, domain A中如果涉及到 domain B的业务逻辑,最好的做法不是把 domain B引入到A中,在domain A中组装参数,调用domain B, 而是通过事件event中去通知domain B,需要做什么样的业务逻辑. 这个概念很重要,一个是A直接调用B,那么你就需要查看B的业务逻辑,另外一个是只需要通知B去做业务逻辑,domain A根本不关系具体怎么做. (这个也是项目开发中很重要的合作概念,多个开发者协作,责任边界要划分清晰,开发者A说,我已经通知B去做了,B没做,那就去找B的问题呗,要不然,嘿嘿... domain A是开发者A的新feature那你就得全权负责)
3. 说了这么一大段,说的还是同一件事,就是各司其职,职责单一,不要越界.

国内很多项目都是急于业务属性的,一般都要求敏捷开发,快速上线,也不是奔着开源来写,所以注定项目开始就是开始对功能,叠屎山,慢慢变得难以维护.
当然python很适合做敏捷开发,解释性语言,语法简单,开发速度快成本低.

就算是屎山也得尽量让他好看一些,毕竟程序员不就是每天得面对这一坨~,接下来就是一些我自己多年来的一些个人经验分享一下
本着做一个web敏捷开发的模版,尽量让项目工程规范化,减少冗余代码,并易于后续拓展.


数据返回结构


来源于网上的一些优秀的编程规程原则先贴在这里,
```markdown
1. SOLID 原则

    SOLID 原则是面向对象编程和设计中的五个基本原则，由 Robert C. Martin (Uncle Bob) 提出。这些原则可以帮助我们创建更灵活、可维护和易于扩展的代码。
    
    S - Single Responsibility Principle (单一职责原则)
        描述: 一个类或模块应该只有一个引起它变化的原因。换句话说，一个类应该只负责一项职责。
        目的: 提高类的内聚性，减少类的耦合性，使其更易于理解、修改和测试。
    
    O - Open/Closed Principle (开闭原则)
        描述: 软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。也就是说，当需要增加新功能时，应该通过扩展现有代码来实现，而不是修改现有代码。
        目的: 减少代码的修改带来的风险，提高代码的复用性和可维护性。

    L - Liskov Substitution Principle (里氏替换原则)
        描述: 子类型必须能够替换它们的基类型。换句话说，任何使用基类型的地方，都可以使用其子类型，而不会出现错误
        目的: 保证代码的正确性和可扩展性，符合面向对象编程的继承原则。
    
    I - Interface Segregation Principle (接口隔离原则)
        描述: 客户端不应该被迫依赖它们不使用的接口。应该将大的接口拆分为更小的、更具体的接口，客户端只需要依赖它们需要的接口。
        目的: 减少类的耦合性，提高系统的灵活性和可复用性。
    
    D - Dependency Inversion Principle (依赖倒置原则)
        描述:高层模块不应该依赖低层模块，两者都应该依赖抽象。
        抽象不应该依赖细节，细节应该依赖抽象。
        目的: 减少模块之间的耦合性，提高代码的灵活性和可维护性。

2. DRY 原则 (Don't Repeat Yourself - 不要重复自己)
    描述: 避免代码重复。 如果你发现你正在写相同的代码多次，应该考虑将其提取到一个方法或类中，并进行复用
    目的: 提高代码的可维护性和复用性，减少代码的错误。
   
3. YAGNI 原则 (You Aren't Gonna Need It - 你不需要它)
    描述: 不要添加你认为将来可能会需要的特性，除非你现在确实需要它。
    目的: 避免过度设计，减少不必要的复杂性，提高开发效率。
   
4. KISS 原则 (Keep It Simple, Stupid - 保持简单，傻瓜式)
    描述: 保持你的代码简单易懂。 避免不必要的复杂性。
    目的: 提高代码的可读性和可维护性，减少错误的发生。

5. Law of Demeter (迪米特法则) / Least Knowledge Principle (最少知识原则)
    描述: 一个对象应该尽可能少地了解其他对象。 对象应该只与它的直接朋友通信。
    目的: 减少对象之间的耦合性，提高代码的灵活性和可维护性。
   
6. Composition over Inheritance (组合优于继承)
    描述: 尽量使用组合的方式来实现代码复用，而不是使用继承。
    目的: 避免继承带来的耦合性和灵活性问题。

```


所以关于建屎山的几点建议来了
1. 项目开始阶段就确定代码规范,特别是多人开发项目,毕竟人和人的思维/经历都不一样
2. 要在项目开始阶段就接入test,否则就再也没机会了.... 比如pytest coverage
3. 


### 关于本项目的依赖[可自行根据需要选择]
1. 项目目录用src结构
2. requirements vs poetry, 选用poetry进行包依赖的管理
3. 使用.pre-commit-config.yaml 对项目进行格式化
4. 使用alembic对数据库迁移进行管理
5. logging vs loguru, 使用loguru替代标准库的logging
6. 使用pyinstrument对项目进行监控
7. 数据类dataclass vs pydantic, 选用pydantic进行数据模型的定义






### 关于数据库有几个优化点
1. API层基于pydantic的自定义scheme 做为请求api的基础模型
2. 基于第一步,实现了业务层->数据库的create/update,无需手动的模型转换
3. 实际业务中的大部分查询都会用到is_deleted这种过滤查询,所处可见的重复代码,不是我们想要的
4. 各个业务service相互调用的时候,数据库的会话管理
5. 


<!--  tree -I "__init__*" -->
## 目录结构



最终 我期望你拿到这个项目的时候,除了可以直接用之外,还帮你做了哪些规范
1. 每次提交自动格式化代码, import导入排序,执行mypy的检查
2. 接入了数据库的迁移标准，alembic进行迁移
3. poetry的包管理工具
4. 测试用例的接入规范,及测试用例的覆盖率
5. 对local/dev/prod的环境变量的管理,读取
6. 对数据库操作的基础封装,不需要写重复查询
7. 基于pydantic的自定义scheme 做为请求api的基础模型
8. api层和service层不同异常的处理逻辑
9. 请求上下文的管理问题
10. 一个漂亮的代码目录结构,哈哈

