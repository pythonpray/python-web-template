# 🚀 **[你的项目名]**：我就是来颠覆你对 Python 项目模板的认知的！😜

##  **哟！这玩意儿是啥？** 🤔

*   **一句话介绍：**  还在对着屎山一样的 Python 代码发愁？哥们儿，你 OUT 了！这玩意儿就是来拯救你的！它就是个 [一句话概括项目功能，比如：基于敏捷开发的 Python Web 项目模板]，简单粗暴，上手就开干！
*   **稍微详细点：**  是不是也像我一样，受够了国内那些只顾上线，不顾后续维护的 “快速开发” 项目？ 每次改需求都像在拆弹，稍不留神就炸了！ 所以，我决定自己搞一个 “有点儿意思” 的 Python 项目模板，它不仅能让你快速上手，还能保持代码的优雅！它能 [详细描述项目功能，比如：快速搭建 Web 应用，提供基础的数据库操作和 API 接口]，而且还融入了一点 “DDD” 的味道，但不完全照搬，毕竟 Python 的优势是快速开发嘛，太复杂没必要！ 😎

##  **怎么玩转这玩意儿？** 🕹️

*   **环境准备：**  想体验这骚操作？先得准备点家伙事儿。Python 装了吗？ Poetry 装了吗？没装？赶紧去！别在这儿磨叽！
*   **安装方法：**  别跟我说你不会安装依赖，这年头谁还不会 `poetry install` 啊？
    ```bash
    poetry install
    ```
    搞定！是不是很简单？
*   **跑起来看看：**  安装好了？那就开跑呗！ 别忘了看看示例代码，不然我怎么知道你有没有认真对待我写的代码？ （这里可以加上一些简单的启动命令）
     ```bash
     # 开发环境启动
     poetry run python src/main.py --env dev 
     ```
     或者 
    ```bash
      # 生产环境启动
     poetry run python src/main.py --env prod 
    ```
    
##  **这代码有啥不一样？** 🧐

*   **拒绝屎山：** 我帮你把代码结构都安排的明明白白的，像什么 `Domain` 、`Service` 、`Repository` ，你都能一目了然，再也不怕找不到代码了。
*   **DRY 原则：** 啥？你还在重复写 `is_deleted=False` ？ 你 OUT 了！  我帮你封装好了！再也不用重复劳动了。
*   **数据模型？小 case：**  `pydantic` 就是个神器，定义数据模型就像写 JSON 一样简单。 它还能自动帮你做数据转换，省事儿！
*   **配置？简单！：** 用 `.ini` 文件管理配置，简单直接，不搞花里胡哨。

## **一些我踩过的坑，给你们避避雷！** 💣

*  **SOLID 原则:**  这些原则不是什么高深的武功秘籍，就是一些让你代码更优雅的小技巧。 记住了，你的类应该只干一件事，不要啥都往里塞！
* **DRY 原则:** 别重复写代码，不然下次维护的时候你会哭的！  能复用的就复用，就像你用的筷子，用完洗洗还能用！
*  **YAGNI 原则:**  别过度设计，你需要什么就写什么， 别没事儿老想着以后要用到，万一以后用不上呢？
*   **KISS 原则：** 保持简单，傻瓜式操作，别搞那么复杂，你不是在造火箭！
* **依赖倒置原则:**  高层模块别依赖低层模块，这样能减少耦合，方便以后扩展。
*   **组合优于继承:** 别没事儿就搞继承，多用组合，更灵活！

## **我给你准备了啥？**🎁

*   **自动格式化代码：** 每次提交代码都自动格式化，让你的代码整整齐齐，强迫症患者的福音！
*   **数据库迁移：** `alembic` 帮你管理数据库迁移，告别手动修改数据库的烦恼！
*   **依赖管理：** `poetry` 帮你管理依赖，再也不用担心版本冲突了！
*   **测试覆盖率：**  写测试用例是程序员的基本素养，没测试覆盖率的代码都是耍流氓！
*   **环境管理：**  `local`, `dev`, `prod` 三种环境，配置灵活切换，想怎么跑就怎么跑！
*   **数据库操作封装：**  不用重复写 CRUD， 直接调用封装好的方法就行了，爽！
*   **请求模型验证：**  用 `pydantic` 定义 API 请求模型，类型校验不在话下！
*   **统一异常处理：**  API 层和 Service 层的异常处理逻辑都给你安排好了，再也不用为异常发愁了！
*   **请求上下文管理：**  每个请求都有自己的上下文，再也不用担心数据混乱了！
*   **漂亮的代码目录：**  目录结构清晰，让你赏心悦目，维护起来也舒心！

##  **目录结构长啥样？** 🌳


总结了一些python开发/部署/调试/目录结构上一些经验
心血来潮,想写一个关于敏捷开发的python项目模板,让大家快速的开发一个python项目,并且拥有一个比较好,易于扩展的的开发模板.
当然我也看到一些好的关于python的DDD设计项目 例如https://github.com/pgorecki/python-ddd

关于环境变量
其实,fastapi引用的pydantic,默认支持.env的文件的加载. 但我感觉.env的格式报好看^.~
所以在不引入第三方库的原则下,我用了from configparser import ConfigParser 去解析xxx.ini的配置文件.

关于代码架构
借鉴了DDD的设计思路,但是也没有完全按照那个规范,毕竟python的优势就是语法简单,快速开发,不想让项目结构变的非常复杂.
这里主要拿了几个重要的概念过来,Domain/Service/Repositories/event等,这些东西能让代码对于业务隔离有很好的帮助



我的开发原则是 能不引入第三方库就不引入!!!

其中Repository模式则是借鉴了DDD(Domain Driven Design)的设计模型. 存储库通常具有 CRUD 方法，例如 create（）、get（） 或 update（）等方法.
在外部调用时,完全不用关注内部逻辑,并对很多通用逻辑做了最大限度的封装,不需要重复写一些基础的get,gets查询;对于通用的is_deleted这种软删除也做了统一处理,不必过多重复的去写is_deleted=False的where条件

当然这个项目的设计是按照敏捷开发模型实现的,如果是更大型的项目推荐使用DDD的设计模型,只需要按照infra/seedwork的模型复制到各个子app中即可,而seedwork只存放一些globals的模块

DDD的架构设计有几个点我觉得在项目设计上很有用,
1. domain的隔离,是做好业务拆分,为后续扩展做好贮备.
domain A 下面有repo A(管理 数据表table A的CRUD), domain B 下有 repo B(管理 数据表table B的CRUD),如果是在A服务中需要更新TABLE B表,那么应该调用domain B对外暴露的接口,而不是直接调用repo B或者直接操作table B的模型.
2. domain event的设计同样如此, domain A中如果涉及到 domain B的业务逻辑,最好的做法不是把 domain B引入到A中,在domain A中组装参数,调用domain B, 而是通过事件event中去通知domain B,需要做什么样的业务逻辑. 这个概念很重要,一个是A直接调用B,那么你就需要查看B的业务逻辑,另外一个是只需要通知B去做业务逻辑,domain A根本不关系具体怎么做. (这个也是项目开发中很重要的合作概念,多个开发者协作,责任边界要划分清晰,开发者A说,我已经通知B去做了,B没做,那就去找B的问题呗,要不然,嘿嘿... domain A是开发者A的新feature那你就得全权负责)
3. 说了这么一大段,说的还是同一件事,就是各司其职,职责单一,不要越界.

国内很多项目都是急于业务属性的,一般都要求敏捷开发,快速上线,也不是奔着开源来写,所以注定项目开始就是开始对功能,叠屎山,慢慢变得难以维护.
当然python很适合做敏捷开发,解释性语言,语法简单,开发速度快成本低.

就算是屎山也得尽量让他好看一些,毕竟程序员不就是每天得面对这一坨~,接下来就是一些我自己多年来的一些个人经验分享一下
本着做一个web敏捷开发的模版,尽量让项目工程规范化,减少冗余代码,并易于后续拓展.


数据返回结构


来源于网上的一些优秀的编程规程原则先贴在这里,
```markdown
1. SOLID 原则

    SOLID 原则是面向对象编程和设计中的五个基本原则，由 Robert C. Martin (Uncle Bob) 提出。这些原则可以帮助我们创建更灵活、可维护和易于扩展的代码。
    
    S - Single Responsibility Principle (单一职责原则)
        描述: 一个类或模块应该只有一个引起它变化的原因。换句话说，一个类应该只负责一项职责。
        目的: 提高类的内聚性，减少类的耦合性，使其更易于理解、修改和测试。
    
    O - Open/Closed Principle (开闭原则)
        描述: 软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。也就是说，当需要增加新功能时，应该通过扩展现有代码来实现，而不是修改现有代码。
        目的: 减少代码的修改带来的风险，提高代码的复用性和可维护性。

    L - Liskov Substitution Principle (里氏替换原则)
        描述: 子类型必须能够替换它们的基类型。换句话说，任何使用基类型的地方，都可以使用其子类型，而不会出现错误
        目的: 保证代码的正确性和可扩展性，符合面向对象编程的继承原则。
    
    I - Interface Segregation Principle (接口隔离原则)
        描述: 客户端不应该被迫依赖它们不使用的接口。应该将大的接口拆分为更小的、更具体的接口，客户端只需要依赖它们需要的接口。
        目的: 减少类的耦合性，提高系统的灵活性和可复用性。
    
    D - Dependency Inversion Principle (依赖倒置原则)
        描述:高层模块不应该依赖低层模块，两者都应该依赖抽象。
        抽象不应该依赖细节，细节应该依赖抽象。
        目的: 减少模块之间的耦合性，提高代码的灵活性和可维护性。

2. DRY 原则 (Don't Repeat Yourself - 不要重复自己)
    描述: 避免代码重复。 如果你发现你正在写相同的代码多次，应该考虑将其提取到一个方法或类中，并进行复用
    目的: 提高代码的可维护性和复用性，减少代码的错误。
   
3. YAGNI 原则 (You Aren't Gonna Need It - 你不需要它)
    描述: 不要添加你认为将来可能会需要的特性，除非你现在确实需要它。
    目的: 避免过度设计，减少不必要的复杂性，提高开发效率。
   
4. KISS 原则 (Keep It Simple, Stupid - 保持简单，傻瓜式)
    描述: 保持你的代码简单易懂。 避免不必要的复杂性。
    目的: 提高代码的可读性和可维护性，减少错误的发生。

5. Law of Demeter (迪米特法则) / Least Knowledge Principle (最少知识原则)
    描述: 一个对象应该尽可能少地了解其他对象。 对象应该只与它的直接朋友通信。
    目的: 减少对象之间的耦合性，提高代码的灵活性和可维护性。
   
6. Composition over Inheritance (组合优于继承)
    描述: 尽量使用组合的方式来实现代码复用，而不是使用继承。
    目的: 避免继承带来的耦合性和灵活性问题。

```


所以关于建屎山的几点建议来了
1. 项目开始阶段就确定代码规范,特别是多人开发项目,毕竟人和人的思维/经历都不一样
2. 要在项目开始阶段就接入test,否则就再也没机会了.... 比如pytest coverage
3. 


### 关于本项目的依赖[可自行根据需要选择]
1. 项目目录用src结构
2. requirements vs poetry, 选用poetry进行包依赖的管理
3. 使用.pre-commit-config.yaml 对项目进行格式化
4. 使用alembic对数据库迁移进行管理
5. logging vs loguru, 使用loguru替代标准库的logging
6. 使用pyinstrument对项目进行监控
7. 数据类dataclass vs pydantic, 选用pydantic进行数据模型的定义






### 关于数据库有几个优化点
1. API层基于pydantic的自定义scheme 做为请求api的基础模型
2. 基于第一步,实现了业务层->数据库的create/update,无需手动的模型转换
3. 实际业务中的大部分查询都会用到is_deleted这种过滤查询,所处可见的重复代码,不是我们想要的
4. 各个业务service相互调用的时候,数据库的会话管理
5. 


<!--  tree -I "__init__*" -->
## 目录结构



最终 我期望你拿到这个项目的时候,除了可以直接用之外,还帮你做了哪些规范
1. 每次提交自动格式化代码, import导入排序,执行mypy的检查
2. 接入了数据库的迁移标准，alembic进行迁移
3. poetry的包管理工具
4. 测试用例的接入规范,及测试用例的覆盖率
5. 对local/dev/prod的环境变量的管理,读取
6. 对数据库操作的基础封装,不需要写重复查询
7. 基于pydantic的自定义scheme 做为请求api的基础模型
8. api层和service层不同异常的处理逻辑
9. 请求上下文的管理问题
10. 一个漂亮的代码目录结构,哈哈

